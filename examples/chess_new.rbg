#game = "Chess"
// notes:
// - no rules about repeating states or tie after given number of turns without pawn moves
// - game is limited to 200 turns


#backLine(color) =
    [color~RookUnmoved, color~Knight, color~Bishop, color~Queen, color~King, color~Bishop, color~Knight, color~RookUnmoved]
#pawnLine(color) =
    [color~Pawn, color~Pawn, color~Pawn, color~Pawn, color~Pawn, color~Pawn, color~Pawn, color~Pawn]
#emptyLine =
    [empty, empty, empty, empty, empty, empty, empty, empty]

#downLineVertex(name; leftName; rightName; upName; startPiece) = name [startPiece] {left: leftName, right: rightName, up: upName}
#leftLineVertex(name; rightName; upName; downName; startPiece) = name [startPiece] {right: rightName, up: upName, down: downName}
#rightLineVertex(name; leftName; upName; downName; startPiece) = name [startPiece] {left: leftName, up: upName, down: downName}
#upLineVertex(name; leftName; rightName; downName; startPiece) = name [startPiece] {left: leftName, right: rightName, down: downName}
#middleVertex(name; leftname; rightName; upName; downName; startPiece) =
    name [startPiece] {left: leftName, right: rightName, up: upName, down: downName}

#downLine(rowNumber; upRowNumber; piece0; piece1; piece2; piece3; piece4; piece5; piece6; piece7) =
    v0~rowNumber [piece0] {up: v0~upRowNumber, right: v1~rowNumber}
    downLineVertex(v1~rowNumber; v0~rowNumber; v2~rowNumber; v1~upRowNumber; piece1)
    downLineVertex(v2~rowNumber; v1~rowNumber; v2~rowNumber; v2~upRowNumber; piece2)
    downLineVertex(v3~rowNumber; v2~rowNumber; v2~rowNumber; v3~upRowNumber; piece3)
    downLineVertex(v4~rowNumber; v3~rowNumber; v2~rowNumber; v4~upRowNumber; piece4)
    downLineVertex(v5~rowNumber; v4~rowNumber; v2~rowNumber; v5~upRowNumber; piece5)
    downLineVertex(v6~rowNumber; v5~rowNumber; v2~rowNumber; v6~upRowNumber; piece6)
    v7~rowNumber [piece7] {up: v7~upRowNumber, left: v6~rowNumber}

#middleLine(rowNumber; upRowNumber; downRowNumber; piece0; piece1; piece2; piece3; piece4; piece5; piece6; piece7) =
    leftLineVertex(v0~rowNumber; v1~rowNumber; v0~upRowNumber; v0~downRowNumber; piece0)
    middleVertex(v1~rowNumber; v0~rowNumber; v2~rowNumber; v1~upRowNumber; v1~downRowNumber; piece1)
    middleVertex(v2~rowNumber; v1~rowNumber; v3~rowNumber; v2~upRowNumber; v2~downRowNumber; piece2)
    middleVertex(v3~rowNumber; v2~rowNumber; v4~rowNumber; v3~upRowNumber; v3~downRowNumber; piece3)
    middleVertex(v4~rowNumber; v3~rowNumber; v5~rowNumber; v4~upRowNumber; v4~downRowNumber; piece4)
    middleVertex(v5~rowNumber; v4~rowNumber; v6~rowNumber; v5~upRowNumber; v5~downRowNumber; piece5)
    middleVertex(v6~rowNumber; v5~rowNumber; v7~rowNumber; v6~upRowNumber; v6~downRowNumber; piece6)
    rightLineVertex(v7~rowNumber; v6~rowNumber; v7~upRowNumber; v7~downrowNumber; piece7)

#upLine(rowNumber; downRowNumber; piece0; piece1; piece2; piece3; piece4; piece5; piece6; piece7) =
    v0~rowNumber [piece0] {right: v1~rowNumber, down: v0~downRowNumber}
    upLineVertex(v1~rowNumber; v0~rowNumber; v2~rowNumber; v1~downRowNumber; piece1)
    upLineVertex(v2~rowNumber; v1~rowNumber; v3~rowNumber; v2~downRowNumber; piece2)
    upLineVertex(v3~rowNumber; v2~rowNumber; v4~rowNumber; v3~downRowNumber; piece3)
    upLineVertex(v4~rowNumber; v3~rowNumber; v5~rowNumber; v4~downRowNumber; piece4)
    upLineVertex(v5~rowNumber; v4~rowNumber; v6~rowNumber; v5~downRowNumber; piece5)
    upLineVertex(v6~rowNumber; v5~rowNumber; v7~rowNumber; v6~downRowNumber; piece6)
    v7~rowNumber [piece7] {left: v6~rowNumber, down: v7~downRowNumber}

#board =
    upLine(7; 6; blackRookUnmoved; blackKnight; blackBishop; blackQueen; blackKing; blackBishop; blackKnight; blackRookUnmoved)
    middleLine(6; 7; 5; blackPawn; blackPawn; blackPawn; blackPawn; blackPawn; blackPawn; blackPawn; blackPawn)
    middleLine(5; 6; 4; empty; empty; empty; empty; empty; empty; empty; empty)
    middleLine(4; 5; 3; empty; empty; empty; empty; empty; empty; empty; empty)
    middleLine(3; 4; 2; empty; empty; empty; empty; empty; empty; empty; empty)
    middleLine(2; 3; 1; empty; empty; empty; empty; empty; empty; empty; empty)
    middleLine(1; 2; 0; whitePawn; whitePawn; whitePawn; whitePawn; whitePawn; whitePawn; whitePawn; whitePawn)
    downLine(0; 1; whiteRookUnmoved; whiteKnight; whiteBishop; whiteQueen; whiteKing; whiteBishop; whiteKnight; whiteRookUnmoved)

#bound = 200

#anyRook(color) = color~RookMoved, color~RookUnmoved
#majorPieces(color) = anyRook(color), color~Knight, color~Bishop, color~Queen
#singleColorPieces(color) = color~Pawn, color~King, majorPieces(color)
#emptyOrColor(color) = singleColorPieces(color), empty
#allPieces = singleColorPieces(white), singleColorPieces(black)


#players = white (11), black (11)
#pieces = allPieces, empty
#variables = pawnDoubleMove (2), whiteKingMoved (2), blackKingMoved (2), turn (202)


#anySquare =
    (
        (right)
      + (left)
      + (up)
      + (down)
    )^*

#anyNeighborSquare =
    (
        (right)
      + (left)
      + (up)
      + (down)
      + (up)(left)
      + (up)(right)
      + (down)(left)
      + (down)(right)
    )

#diagonalLine =
    (
        ((up)(left)(empty))^*(up)(left)
      + ((up)(right)(empty))^*(up)(right)
      + ((down)(left)(empty))^*(down)(left)
      + ((down)(right)(empty))^*(down)(right)
    )

#parallelLine =
    (
        ((up)(empty))^*(up)
      + ((down)(empty))^*(down)
      + ((right)(empty))^*(right)
      + ((left)(empty))^*(left)
    )

#anyDirectionLine =
    (
        diagonalLine
      + parallelLine
    )

#knightHop =
    (
        (up)^2(left)
      + (up)^2(right)
      + (down)^2(left)
      + (down)^2(right)
      + (right)^2(up)
      + (right)^2(down)
      + (left)^2(up)
      + (left)^2(down)
    )

#captureAnyBy(capturingPiece; opponentColor) =
    (emptyOrColor(opponentColor))
    [capturingPiece]

#pickUpPiece(piece) =
    (piece)[empty]

#standardMove(piece; movePattern; opponentColor) =
    pickUpPiece(piece)
    movePattern
    captureAnyBy(piece; opponentColor)

#bishopMove(color; opponentColor) = standardMove(color~Bishop; diagonalLine; opponentColor)
#knightMove(color; opponentColor) = standardMove(color~Knight; knightHop; opponentColor)
#queenMove(color; opponentColor) = standardMove(color~Queen; anyDirectionLine; opponentColor)

#rookMove(color; opponentColor) =
    pickUpPiece(anyRook(color))
    parallelLine
    captureAnyBy(color~RookMoved; opponentColor)

#standardKingMove(color; opponentColor) =
    standardMove(color~King; anyNeighborSquare; opponentColor)
    [$color~KingMoved=1]

#isAttackedByBishop(opponentColor) = diagonalLine(opponentColor~Bishop)
#isAttackedByRook(opponentColor) = parallelLine(anyRook(opponentColor))
#isAttackedByQueen(opponentColor) = anyDirectionLine(opponentColor~Queen)
#isAttackedByKnight(opponentColor) = knightHop(opponentColor~Knight)
#isAttackedByKing(opponentColor) = anyNeighborSquare(opponentColor~King)
#isAttackedByPawn(opponentColor; forwardDirection) =
    ((right)(forwardDirection) + (left)(forwardDirection))(opponentColor~Pawn)

#isNotAttackedBy(opponentColor; forwardDirection) =
    (!
        isAttackedByBishop(opponentColor)
      + isAttackedByRook(opponentColor)
      + isAttackedByQueen(opponentColor)
      + isAttackedByKnight(opponentColor)
      + isAttackedByKing(opponentColor)
      + isAttackedByPawn(opponentColor; forwardDirection)
    )

#checked(color; opponentColor; forwardDirection) =
    anySquare
    (color~King)
    (
        isAttackedByBishop(opponentColor)
      + isAttackedByRook(opponentColor)
      + isAttackedByQueen(opponentColor)
      + isAttackedByKnight(opponentColor)
      + isAttackedByKing(opponentColor)
      + isAttackedByPawn(opponentColor; forwardDirection)
    )

#castlingKingMove(forwardDirection; color; opponentColor) =
    (? $color~KingMoved==0)
    pickUpPiece(color~King)
    (
        ((right)(empty)isNotAttackedBy(opponentColor; forwardDirection))^2
        [color~King]
        (right)pickUpPiece(color~RookUnmoved)
        (left)^2
      + ((left)(empty)isNotAttackedBy(opponentColor; forwardDirection))^2
        [color~King]
        (left)(empty) // rook CAN pass through attacked square
        (left)pickUpPiece(color~RookUnmoved)
        (right)^3
    )
    [color~RookMoved]
    [$color~KingMoved=1]

#kingMove(forwardDirection; color; opponentColor) =
    (
        castlingKingMove(forwardDirection; color; opponentColor)
      + standardKingMove(color; opponentColor)
        isNotAttackedBy(opponentColor; forwardDirection)
    )

#checkForPromotion(forwardDirection; color) =
    (
        (? (forwardDirection))[color~Pawn]
      + (! (forwardDirection))[majorPieces(color)]
    )

#standardPawnMove(forwardDirection; backDirection; color; opponentColor) =
    pickUpPiece(color~Pawn)
    (
        // promotion cannot occur
        (! (backDirection)^2)
        ((forwardDirection)(empty))^2
        [color~Pawn]
        [$pawnDoubleMove=1]
      + (
            (forwardDirection)(empty)
          + ((right)(forwardDirection)+(left)(forwardDirection))(singleColorPieces(opponentColor))
        )
        checkForPromotion(forwardDirection; color)
    )

#enPassantPawnMove(forwardDirection; color) =
    (? $pawnDoubleMove==1)
    (
        // we are sure that adjacent cell is occupied by opponentColor~Pawn, because pawnDoubleMove==1, so don't check it
        (right)pickUpPiece(color~Pawn)
        (left)
      + (left)pickUpPiece(color~Pawn)
        (right)
    )
    [empty]
    (forwardDirection)
    [$pawnDoubleMove=0]
    [color~Pawn]

#allMoves(forwardDirection; backDirection; color; opponentColor) =
    (
        anySquare
        [$pawnDoubleMove=0]
        (
            bishopMove(color; opponentColor)
          + rookMove(color; opponentColor)
          + knightMove(color; opponentColor)
          + queenMove(color; opponentColor)
          + kingMove(forwardDirection; color; opponentColor)
          + standardPawnMove(forwardDirection; backDirection; color; opponentColor)
        )
      + enPassantPawnMove(forwardDirection; color)
    )(! checked(color; opponentColor; forwardDirection))
    (
        (? checked(opponentColor; color; backDirection))[$opponentColor=0,$color=10]
     >+ [$color=5,$opponentColor=5]
    )
    (
        (? $turn>200)->()
     >+ [$turn=$turn+1]->opponentColor
    )

#rules =
    (
        allMoves(up;down;white;black)
        allMoves(down;up;black;white)
    )^*

